#!/usr/bin/python3
import re
import sys

import data_analysis as da

from functools import reduce
from parsing_helper import INFO_REGEXP, parse_event, parse_events
from total_order_checker import check_actors_total_order


class ParseEventException(Exception):
    def __init__(self, message=None):
        if not message:
            super().__init__("Event string representation expected.")
        else:
            super().__init__(message)


def parse_logs(log_file, msg_filter_func=lambda x: False):
    """
    Given a log file perform the parsing collecting data for further
    processing. If a filter function is given it is applied to
    message ids in order to filter them.
    """
    actor_regexp = re.compile(INFO_REGEXP)

    # the set of actors that have either broadcast or
    # delivered a message
    actors = set()
    # the set of actor+message_id
    # for messages broadcast
    broadcast = set()
    # for each message (actor+messageid)
    # corresponds a list of actors who delivered
    # the message
    delivered = dict()
    # for each actor, list messages ordered by delivery
    delivery_order = dict()

    # dictionary containing
    delta_msg = {}
    with open(log_file, "r") as fh:
        for line in fh:
            match = actor_regexp.match(line)
            if not match:
                continue
            actor, ts, lclock, action, argument = match.groups()
            if actor not in actors:
                actors.add(actor)
            time = ts
            if actor not in delivery_order:
                delivery_order[actor] = []

            if "broadcast" in action:
                ts, source, msg_id = parse_event(argument)
                message = "{}:{}".format(source,msg_id)
                # perform the message filtering
                if msg_filter_func(message):
                    continue
                broadcast.add(message)
                delivered[message] = []
                delta_msg[message] = {"at" : time, "actors" : []}

            elif "delivered" in action:
                delivered_events = re.compile(r"\s*{\s+([^}]*)\s+}")
                deliveryat = time
                delivered_events = delivered_events.match(argument).groups()[0]
                for _, e_source, e_id, _ in parse_events(delivered_events):
                    message = "{}:{}".format(e_source, e_id)
                    if message not in delivered:
                        delivered[message] = [actor]
                    else:
                        delivered[message].append(actor)
                        # add message to the delivery list for
                        # the current actor
                        delivery_order[actor].append(message)
                        delta_msg[message]["actors"].append(deliveryat)
                
    return actors, broadcast, delivered, delivery_order, delta_msg

def print_agreement(msg_delivery_rate):
    for msg, drate in msg_delivery_rate.items():
        print("{} delivery perc: {}%".format(msg, drate))


def summary(num_actors, epoch, num_messages, avg_msg, min_drate, max_drate):
    return "Total actors: {}\n".format(num_actors) +\
    "Epoch: {}-{}\n".format(epoch[0], epoch[1]) +\
    "Total messages: {}\n".format(num_messages) +\
    "Avg messages per actor: {}\n".format(avg_msg) +\
    "Lowest delivery rate: {}\n".format(min_drate) +\
    "Highest delivery rate: {}\n".format(max_drate)


if __name__ == "__main__":
    """
    Compute the following

    1. the total number of actors
    2. the total number of messages generated
    3. the average number of messages generated by a single actor
    4. the minimum and maximum delivery rate found, considering
       all the messages.
    """    
    filter_func = lambda x: da.filter_msg(x, 0, 150)
    #filter_func = lambda x: False
    actors, broadcast, msg_delivery, delivery_order, delta_msg = parse_logs(sys.argv[1], filter_func)

    # msg_delivery contains an entry for each message
    # broadcast. Filter entries not delivered by ANY actor.
    #
    # i.e: delivered_messages contains an entry for each message delivered
    # at least once.
    delivered_messages  = {message : actor_list\
                           for message, actor_list in msg_delivery.items()\
                           if len(actor_list) > 0}

    actor_msg     = da.compute_actor_msg(delivered_messages)
    num_actors   = len(actors)
    num_messages = len(reduce(lambda x,y: list(x) + list(y), actor_msg.values()))
    avg_msg      = int(num_messages / num_actors)

    epoch = da.compute_epoch(actor_msg)

    delivery_rate =  da.compute_delivery_rate(delivered_messages, num_actors)
    min_drate = min(delivery_rate.values())
    max_drate = max(delivery_rate.values())

    print(summary(num_actors, epoch, num_messages, avg_msg,\
                  min_drate, max_drate))

    bins = da.plot_drate_pdf(delivery_rate)
    
    delays1 = da.compute_delivery_delay(delta_msg)
    delays2 = list(da.delay_count(delays1, num_actors))
    delays3 = da.sum_delivery_fraction(delays2)
    da.plot_count(delays3)
